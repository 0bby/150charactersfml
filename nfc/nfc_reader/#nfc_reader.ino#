/**************************************************************************/
/*!
    Dual PN532 NFC reader for Raspberry Pi Pico.

    Two PN532 boards share the hardware SPI bus (SCK, MOSI, MISO) and are
    selected by separate chip-select (SS) pins.  The firmware polls each
    reader in turn with a short timeout and prints any NDEF text payload
    prefixed with the reader number:

        PAYLOAD:1:<text>      (from reader 1)
        PAYLOAD:2:<text>      (from reader 2)

    Wiring (Pico default SPI0):
        SCK   -> GP18  (shared)
        MOSI  -> GP19  (shared)
        MISO  -> GP16  (shared)
        SS1   -> GP4   (reader 1 chip select)
        SS2   -> GP9   (reader 2 chip select)

    Both PN532 boards need SCK/MOSI/MISO wired in parallel; only SS differs.
    Set each PN532 to SPI mode (DIP switches / solder jumpers).
*/
/**************************************************************************/
#include <SPI.h>
#include <Adafruit_PN532.h>

// Chip-select pins â€” one per reader
#define PN532_SS_1  (4)
#define PN532_SS_2  (9)

// Number of readers
#define NUM_READERS 2

// Hardware SPI with manual chip-select
Adafruit_PN532 readers[NUM_READERS] = {
    Adafruit_PN532(PN532_SS_1),
    Adafruit_PN532(PN532_SS_2),
};

// Debounce: ignore the same UID on the same reader for this many ms
#define DEBOUNCE_MS 2000
uint8_t  lastUID[NUM_READERS][7];
uint8_t  lastUIDLen[NUM_READERS];
uint32_t lastReadTime[NUM_READERS];

/**************************************************************************/
/*!  Return true if uid matches the last-seen UID on this reader.         */
/**************************************************************************/
static bool isSameTag(int r, uint8_t *uid, uint8_t uidLen)
{
[O    if (uidLen != lastUIDLen[r]) return false;
    return memcmp(uid, lastUID[r], uidLen) == 0;
}

/**************************************************************************/
/*!  Walk NTAG2xx user pages and print any NDEF text/URI payload.         */
/**************************************************************************/
static void readAndPrintNDEF(int readerIdx)
{
    Adafruit_PN532 &nfc = readers[readerIdx];

    // Read user pages 4-48 (180 bytes â€” enough for ~150 char payloads)
    uint8_t data[180];
    uint8_t pageBuf[16];
    bool readOk = true;

    for (uint8_t page = 4; page < 49; page++) {
        if (!nfc.mifareultralight_ReadPage(page, pageBuf)) {
            readOk = false;
            break;
        }
        memcpy(&data[(page - 4) * 4], pageBuf, 4);
    }

    if (!readOk) {
        Serial.println("Failed to read tag pages");
        return;
    }

    // Walk TLV blocks to find NDEF message (type 0x03)
    int off = 0;
    while (off < (int)sizeof(data)) {
        uint8_t tlvType = data[off++];
        if (tlvType == 0x00) continue;   // NULL TLV
        if (tlvType == 0xFE) break;      // Terminator

        // Read TLV length (1 or 3 bytes)
        uint16_t tlvLen;
        if (data[off] == 0xFF) {
            off++;
            tlvLen = ((uint16_t)data[off] << 8) | data[off + 1];
            off += 2;
        } else {
            tlvLen = data[off++];
        }

        if (tlvType != 0x03) {
            off += tlvLen; // skip non-NDEF TLVs
            continue;
        }

        // Parse NDEF record header
        uint8_t flags   = data[off];
        uint8_t typeLen  = data[off + 1];
        bool    sr       = flags & 0x10;
        bool    il       = flags & 0x08;
        uint8_t tnf      = flags & 0x07;
        int     pos      = off + 2;

        uint32_t payloadLen;
        if (sr) {
            payloadLen = data[pos++];
        } else {
            payloadLen = ((uint32_t)data[pos] << 24) | ((uint32_t)data[pos+1] << 16) |
                         ((uint32_t)data[pos+2] << 8) | data[pos+3];
            pos += 4;
        }

        uint8_t idLen = 0;
        if (il) idLen = data[pos++];

        uint8_t recType = data[pos];
        pos += typeLen; // skip type field
        pos += idLen;   // skip ID field

        // Strip NDEF record overhead to get raw text
        if (tnf == 0x01 && typeLen == 1 && recType == 'T') {
            // NFC Forum Text Record: skip status byte + language code
            uint8_t langLen = data[pos] & 0x3F;
            pos += 1 + langLen;
            payloadLen -= 1 + langLen;
        } else if (tnf == 0x01 && typeLen == 1 && recType == 'U') {
            // NFC Forum URI Record: skip URI prefix byte
            pos += 1;
            payloadLen -= 1;
        }

        // Print with reader prefix:  PAYLOAD:<reader>:<text>
        Serial.print("PAYLOAD:");
        Serial.print(readerIdx + 1);  // 1-indexed
        Serial.print(":");
        for (uint32_t j = 0; j < payloadLen && (pos + (int)j) < (int)sizeof(data); j++) {
            Serial.print((char)data[pos + j]);
        }
        Serial.println();
        break;
    }
}

/**************************************************************************/
/*!  Arduino setup â€” initialise both readers.                             */
/**************************************************************************/
void setup(void)
{
    Serial.begin(115200);
    while (!Serial) delay(10);

    Serial.println("Hello! Dual-reader NFC init");

    for (int r = 0; r < NUM_READERS; r++) {
        readers[r].begin();

        // Fail fast: only try once per poll (non-blocking-ish)
        readers[r].setPassiveActivationRetries(0x01);

        uint32_t versiondata = readers[r].getFirmwareVersion();
        if (!versiondata) {
            Serial.print("Didn't find PN53x board on reader ");
            Serial.println(r + 1);
            // Don't halt â€” the other reader may still work
            continue;
        }
        Serial.print("Reader ");
        Serial.print(r + 1);
        Serial.print(": PN5");
        Serial.print((versiondata >> 24) & 0xFF, HEX);
        Serial.print(" fw ");
        Serial.print((versiondata >> 16) & 0xFF, DEC);
        Serial.print('.');
        Serial.println((versiondata >> 8) & 0xFF, DEC);

        // Configure to read ISO14443A tags
        readers[r].SAMConfig();

        lastUIDLen[r] = 0;
        lastReadTime[r] = 0;
    }

    Serial.println("Waiting for an ISO14443A Card ...");
}

/**************************************************************************/
/*!  Main loop â€” poll each reader in turn.                                */
/**************************************************************************/
void loop(void)
{
    for (int r = 0; r < NUM_READERS; r++) {
        uint8_t uid[7] = {0};
        uint8_t uidLength = 0;

        // Short timeout (200 ms) so we don't block the other reader for long
        bool found = readers[r].readPassiveTargetID(
            PN532_MIFARE_ISO14443A, uid, &uidLength, 200);

        if (!found) continue;

        // Debounce: skip if same tag was just read on this reader
        uint32_t now = millis();
        if (isSameTag(r, uid, uidLength) &&
            (now - lastReadTime[r]) < DEBOUNCE_MS) {
            continue;
        }

        // Remember this tag for debounce
        memcpy(lastUID[r], uid, uidLength);
        lastUIDLen[r] = uidLength;
        lastReadTime[r] = now;

        Serial.print("Reader ");
        Serial.print(r + 1);
        Serial.print(": Found ISO14443A card, UID ");
        Serial.print(uidLength, DEC);
        Serial.println(" bytes");

        if (uidLength == 4) {
            uint32_t cardid = ((uint32_t)uid[0] << 24) | ((uint32_t)uid[1] << 16) |
                              ((uint32_t)uid[2] << 8)  | uid[3];
            Serial.print("Mifare Classic #");
            Serial.println(cardid);
        }

        if (uidLength == 7) {
            Serial.println("Detected NTAG2xx tag");
            readAndPrintNDEF(r);
        }

        Serial.println();
    }
}
